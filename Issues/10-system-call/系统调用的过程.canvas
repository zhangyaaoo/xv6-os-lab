{
	"nodes":[
		{"type":"text","text":"```asm\n00000000000005ca <open>:\n.global open\nopen:\n li a7, SYS_open\n 5ca:\t48bd                li\ta7,15\n ecall\n 5cc:\t00000073          ecall\n ret\n 5d0:\t8082                ret\n```\nopen 系统调用号放在 a7 中，然后执行 ecall","id":"2d2257c693e1279f","x":140,"y":-85,"width":560,"height":310,"color":"5"},
		{"type":"text","text":"ecall 指令触发异常，CPU 硬件自动执行如下的操作：\n1. If the trap is a device interrupt, and the sstatus SIE bit is clear, don’t do any of the following.\n2. Disable interrupts by clearing the SIE bit in sstatus.\n3. Copy the pc to sepc.\n4. Save the current mode (user or supervisor) in the SPP bit in sstatus.\n5. Set scause to reflect the trap’s cause.\n6. Set the mode to supervisor.\n7. Copy stvec to the pc.\n8. Start executing at the new pc.","id":"0bebd4ffe88a90f5","x":-10,"y":700,"width":860,"height":300,"color":"1"},
		{"id":"0ec2f353185c2a89","type":"text","text":"1. 保存31个寄存器；\n2. 设置SP为当前用户态进程对应的内核态的栈指针；；\n3. 切页表；\n4. 跳转到 `usertrap()` 执行。\n\n```asm\ntrampoline:\n.align 4\n.globl uservec\nuservec:\n        #\n        # trap.c sets stvec to point here, so\n        # traps from user space start here,\n        # in supervisor mode, but with a\n        # user page table.\n        #\n\n        # save user a0 in sscratch so\n        # a0 can be used to get at TRAPFRAME.\n        csrw sscratch, a0\n\n        # each process has a separate p->trapframe memory area,\n        # but it's mapped to the same virtual address\n        # (TRAPFRAME) in every process's user page table.\n        li a0, TRAPFRAME\n\n        # save the user registers in TRAPFRAME\n        sd ra, 40(a0)\n        sd sp, 48(a0)\n        sd gp, 56(a0)\n\t\t:\n\t\t:\n         sd t3, 256(a0)\n        sd t4, 264(a0)\n        sd t5, 272(a0)\n        sd t6, 280(a0)\n\n        # save the user a0 in p->trapframe->a0, see struct trapframe at proc.h\n        csrr t0, sscratch\n        sd t0, 112(a0)\n\n        # initialize kernel stack pointer, from p->trapframe->kernel_sp\n        # 进程创建时，第一次返回用户态之前，需要设置进程对应内核态线程的栈指针\n        ld sp, 8(a0)\n\n        # make tp hold the current hartid, from p->trapframe->kernel_hartid\n        # 进程创建时，第一次返回用户态之前设置\n        ld tp, 32(a0)\n\n        # load the address of usertrap(), from p->trapframe->kernel_trap\n        ld t0, 16(a0)\n\n\n        # fetch the kernel page table address, from p->trapframe->kernel_satp.\n        ld t1, 0(a0)\n\n        # wait for any previous memory operations to complete, so that\n        # they use the user page table.\n        sfence.vma zero, zero\n\n        # install the kernel page table.\n        csrw satp, t1\n\n        # flush now-stale user entries from the TLB.\n        sfence.vma zero, zero\n\n        # jump to usertrap(), which does not return\n        jr t0\n```","x":-760,"y":1120,"width":708,"height":500,"color":"2"},
		{"type":"text","text":"```c\nvoid ls(char *path)\n{\n\tchar buf[512], *p;\n\tint fd;\n\tstruct dirent de;\n\tstruct stat st;\n\n\tif((fd = open(path, 0)) < 0){ // open 系统调用\n\t\tfprintf(2, \"ls: cannot open %s\\n\", path);\n\t\treturn;\n\t}\n\t:\n```\n对应的反汇编如下，第一个参数放在 a0 中，第二个参数放在 a1 中：\n```asm\nvoid ls(char *path)\n{\n  be:\td9010113          \taddi\tsp,sp,-624\n  c2:\t26113423          \tsd\tra,616(sp)\n  c6:\t26813023          \tsd\ts0,608(sp)\n  ca:\t24913c23          \tsd\ts1,600(sp)\n  ce:\t25213823          \tsd\ts2,592(sp)\n  d2:\t25313423          \tsd\ts3,584(sp)\n  d6:\t25413023          \tsd\ts4,576(sp)\n  da:\t23513c23          \tsd\ts5,568(sp)\n  de:\t1c80                addi\ts0,sp,624\n  e0:\t892a                mv\ts2,a0\n  char buf[512], *p;\n  int fd;\n  struct dirent de;\n  struct stat st;\n\n  if((fd = open(path, 0)) < 0){\n  e2:\t4581                li\ta1,0\n  e4:\t00000097          \tauipc\tra,0x0\n  e8:\t4e6080e7          \tjalr\t1254(ra) # 5ca <open>\n  ec:\t08054163          \tbltz\ta0,16e <ls+0xb0>\n  f0:\t84aa                mv\ts1,a0\n    fprintf(2, \"ls: cannot open %s\\n\", path);\n    return;\n  }\n```","id":"ec97c784d5ffd087","x":-680,"y":-242,"width":699,"height":625,"color":"5"}
	],
	"edges":[
		{"id":"a703648a9e0663cc","fromNode":"ec97c784d5ffd087","fromSide":"right","toNode":"2d2257c693e1279f","toSide":"left"},
		{"id":"68b74dd2ec439298","fromNode":"2d2257c693e1279f","fromSide":"bottom","toNode":"0bebd4ffe88a90f5","toSide":"top"},
		{"id":"34a6a492210efa42","fromNode":"0bebd4ffe88a90f5","fromSide":"bottom","toNode":"0ec2f353185c2a89","toSide":"top"}
	]
}